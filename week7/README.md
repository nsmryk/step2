# 課題7
## 行列積でループ順序を入れ替える

### 実行方法

```
g++ -std=c++17 matrix.cpp && ./a.out
```

### 実行結果
matrix.cppで実行時間を測定してグラフ化すると以下のようになった。

![](download.png)

行列の大きさは100,200...800としてそれぞれのループ順序において10回ずつ計測を繰り返し、
その平均と標準偏差をとっている。

実行時間の平均
|100|200|300|400|500|600|700|800|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|ijk | 0.00389|0.025585|0.095202|0.221227|0.483959|0.964243|1.613718|2.727851|
|ikj | 0.003672|0.024667|0.082993|0.196458|0.424358|0.804693|1.313768|2.224190|
|jik | 0.003758|0.024868|0.089493|0.212573|0.459405|0.934593|1.468478|2.321718|
|jki | 0.003859|0.026983|0.09601|0.250903|0.589452|1.172847|2.013691|3.289230|
|kij | 0.003641|0.024523|0.082952|0.205897|0.444149|0.879141|1.364648|2.444236|
|kji | 0.00379|0.027989|0.097107|0.252863|0.570536|1.145491|1.887942|2.901852|

実行時間の標準偏差
|100|200|300|400|500|600|700|800|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|ijk | 0.001241|0.001366|0.010589|0.01585|0.096853|0.117921|0.262819|0.633333|
|ikj | 0.000947|0.000624|0.001668|0.003631|0.043663|0.078476|0.127214|0.572462|
|jik | 0.000987|0.000715|0.002471|0.005153|0.032366|0.173215|0.134256|0.336595|
|jki | 0.000912|0.000925|0.00361|0.010762|0.119651|0.132545|0.239257|0.812149|
|kij | 0.000785|0.001325|0.001519|0.020826|0.059874|0.130267|0.100218|0.675128|
|kji | 0.000827|0.001803|0.002734|0.009077|0.045978|0.137419|0.123236|0.372341|

ikj,jik,kijが速く、jik,kji,ijkが時間がかかることがわかった。

## なぜpythonではループ順序を入れ替えても実行時間が変化しないのか
pythonでは構文木に翻訳してプログラムを実行していくところに時間がかかる。
その時間に対してデータがキャッシュにのっているかどうかでデータにアクセスする時間は微々たる差であるのでpythonではループ順序で実行時間がそれほど変わらない。

## TSPChallenge 6,7

### 実行方法
solver_mine2.cppを含むディレクトリ内で以下のコマンドを実行するとoutput_{i}.csvにtour(求められた経路)が出力される。

```
g++ -std=c++17 solver_mine2.cpp && ./a.out
```
### Kruskal,2-opt,Or-opt
solver_mine2.cppで`solve()`を用いる時
前回は初期回をgreedy法で作っていたが、今回はグラフの最小木を求めて、それをもとに初期解を作成した。
得られた初期解をもとに距離を減らせるよう改善して解を求めた。
#### step1 最小木から初期解を作る
Kruskal法で最小木を求めた後に木の枝をすべて二重にして一筆書きのように辿っていく。
たどる途中で訪れたノードをtourに入れていく。ここですでに訪れたノードはtourに入れずに次のノードに進む。

#### step2 2-opt法で改善
スライドにあった方法で解を改善していく。交差する枝を探索して、それを交差しない形に変更することを繰り返す。

#### step3 Or-opt法で改善
ある枝と連続する三点をとる。この時に選んだ枝を(A,B), 三点をN,C,Mとする。
ここでA-B, N-C-MをA-C-BとN-Mにつなぎかえてコスト削減できるか調べる。
距離が減るのならCをA,Bの間に祖運輸してN,Mの間から削除する。
この動作を反復する。これは1.5-Opt法と書かれていたが、(<https://mie-u.repo.nii.ac.jp/?action=repository_action_common_download&item_id=5071&item_no=1&attribute_id=17&file_no=1>)
Or-Opt法で部分列を元の場所から他の場所に繋ぎかえる時の部分列の長さを1と限定した時の場合とみてOr-Optとしている。

#### step4 2-opt法とOr-opt法がどちらも改善されなくなるまで繰り返す

### AntColonyAlgorithm
solver_mine2.cppで`solve_use_ant()`を用いる時
AntColonyAlgorithmで初期解を求めた後に2-optや1.5optを繰り返す
#### step1 AntColonyAlgorithmを用いて初期解を作る
遺伝的アルゴリズムやSAと同系統のアルゴリズム。
確率的な処理をすることで局所最適解に止まることを防げるという利点を持つ。
蟻が餌を巣に運ぶとき他の蟻と影響しあって次第に最短経路を通って餌を運ぶようになることを使っている。
最短経路になるのは蟻が他の蟻のフェロモンを辿って移動するため、最短経路のフェロモンは同じ時間で考えた時に
他の経路より多く通られるのでフェロモンが濃くなる。よって短い経路ほど蟻に選択されやすくなる。
このアルゴリズムではフェロモンの大きさによって蟻がその経路を選択する確率を求め、その確率に従って蟻を移動させる。
移動させる中で最短経路を記録しておき、一定の時間(パラメータとして変更可能)繰り返した後に最短経路をtourとして返している。
また、局所解に陥らないようにフェロモンはある時間経ったら消えるものとする。

#### step2 2-opt法、Or-opt法で改善
上と同じ

